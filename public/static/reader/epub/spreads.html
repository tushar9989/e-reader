<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Spreads Example</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
  <script src="epub.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

</head>
<body>
  <!-- <div id="title"></div> -->
  <select id="toc"></select>
  <div id="viewer" class="spreads"></div>
  <a id="prev" href="#prev" class="arrow">‹</a>
  <a id="next" href="#next" class="arrow">›</a>

  <script>
    var params = URLSearchParams && new URLSearchParams(document.location.search.substring(1));
    var id = params && params.get("id") && decodeURIComponent(params.get("id"));
    var BOOK_ID = id;
    var HISTORY_VERSION;

    // Load the opf
    if (id) {
        id = "/download/" + id + ".epub";
    }

    var book = ePub(id || "https://s3.amazonaws.com/moby-dick/moby-dick.epub");
    var rendition = book.renderTo("viewer", {
      width: "100%",
      height: "80%",
    });

    rendition.display();

    book.ready.then(function() {

    if (BOOK_ID) {
        makeRequest(
        "/history/get/" + BOOK_ID,
        "GET",
        function(xhr) {
          if (xhr.status !== 200) {
            console.error("get history failed.", xhr.statusText);
          }

          var res = JSON.parse(xhr.response);
          HISTORY_VERSION = res.version;
          if (res.data != "") {
            rendition.display(res.data);
          }
        }
      )

      setInterval(saveHistory, 10000);
      }

      var next = document.getElementById("next");

      next.addEventListener("click", function(e){
        book.package.metadata.direction === "rtl" ? rendition.prev() : rendition.next();
        e.preventDefault();
      }, false);

      var prev = document.getElementById("prev");
      prev.addEventListener("click", function(e){
        book.package.metadata.direction === "rtl" ? rendition.next() : rendition.prev();
        e.preventDefault();
      }, false);

      var keyListener = function(e){

        // Left Key
        if ((e.keyCode || e.which) == 37) {
          book.package.metadata.direction === "rtl" ? rendition.next() : rendition.prev();
        }

        // Right Key
        if ((e.keyCode || e.which) == 39) {
          book.package.metadata.direction === "rtl" ? rendition.prev() : rendition.next();
        }

      };

      rendition.on("keyup", keyListener);
      document.addEventListener("keyup", keyListener, false);

    })

    var title = document.getElementById("title");

    rendition.on("rendered", function(section){
      var current = book.navigation && book.navigation.get(section.href);

      if (current) {
        var $select = document.getElementById("toc");
        var $selected = $select.querySelector("option[selected]");
        if ($selected) {
          $selected.removeAttribute("selected");
        }

        var $options = $select.querySelectorAll("option");
        for (var i = 0; i < $options.length; ++i) {
          let selected = $options[i].getAttribute("ref") === current.href;
          if (selected) {
            $options[i].setAttribute("selected", "");
          }
        }
      }
    });

    rendition.on("relocated", function(location){
      console.log(location);
      updateCurrentPage(location.start.cfi);

      var next = book.package.metadata.direction === "rtl" ?  document.getElementById("prev") : document.getElementById("next");
      var prev = book.package.metadata.direction === "rtl" ?  document.getElementById("next") : document.getElementById("prev");

      if (location.atEnd) {
        next.style.visibility = "hidden";
      } else {
        next.style.visibility = "visible";
      }

      if (location.atStart) {
        prev.style.visibility = "hidden";
      } else {
        prev.style.visibility = "visible";
      }

    });

    rendition.on("layout", function(layout) {
      let viewer = document.getElementById("viewer");

      if (layout.spread) {
        viewer.classList.remove('single');
      } else {
        viewer.classList.add('single');
      }
    });

    window.addEventListener("unload", function () {
      console.log("unloading");
      this.book.destroy();
    });

    book.loaded.navigation.then(function(toc){
			var $select = document.getElementById("toc"),
					docfrag = document.createDocumentFragment();

			toc.forEach(function(chapter) {
				var option = document.createElement("option");
				option.textContent = chapter.label;
				option.setAttribute("ref", chapter.href);

				docfrag.appendChild(option);
			});

			$select.appendChild(docfrag);

			$select.onchange = function(){
					var index = $select.selectedIndex,
							url = $select.options[index].getAttribute("ref");
					rendition.display(url);
					return false;
			};

        });
        
    var CURRENT_PAGE = "";
    var NEEDS_UPDATE = false;

    var updateCurrentPage = debounce(function(page) {
    if (CURRENT_PAGE !== page) {
        CURRENT_PAGE = page;
        NEEDS_UPDATE = true;
    }
    }, 250);

    var saveHistory = function() {
        if (!BOOK_ID) {
            return
        }

        if (NEEDS_UPDATE) {
            makeRequest(
            "/history/set/" + BOOK_ID,
            "POST",
            function(xhr) {
                if (xhr.status !== 201) {
                console.error("save history failed.", xhr.statusText);
                return
                }
                NEEDS_UPDATE = false;

                var res = JSON.parse(xhr.response);
                HISTORY_VERSION = res.version;
            },
            {
                "data": "" + CURRENT_PAGE + "",
                "version": HISTORY_VERSION
            }
            )
        }
    };

    function debounce(func, wait, immediate) {
        var timeout;
        return function() {
            var context = this, args = arguments;
            var later = function() {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(context, args);
        };
    };

    function makeRequest(url, method, callback, data) {
        var xhr = new XMLHttpRequest();
        xhr.open(method, url, true);
        xhr.onload = function () {
            if (xhr.readyState === 4) {
            callback(xhr);
            } else {
            console.error(xhr.statusText);
            }
        };

        xhr.onerror = function () {
            console.error(xhr.statusText);
        };

        if (data == undefined) {
            xhr.send(null);
        } else {
            xhr.send(JSON.stringify(data))
        }
    }

  </script>

</body>
</html>